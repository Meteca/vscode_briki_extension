<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MBC-WB Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MBC-WB Documentation
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('advanced_ctrl.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Advanced control features</div>  </div>
</div><!--header-->
<div class="contents">
	<h2>Introduction</h2>
	<p align=justify>
	If your application needs to use sensors and/or actuators it is best to use the SAMD21 to interact with them. Even if the ESP32 is a powerful microcontroller, the FreeRTOS OS it comes with may cause some problems if you are trying to reach real time controlling. 
	Besides, SAMD21 can reach better performances in both analog signals acquisition/generation, in PWM generation.
	<br>
	<br>
	Arduino framework comes with a set of predefined APIs to manage analog and PWM pins. These APIs are generic for all the boards and can be quite limiting if you need to get a more specific configuration. 
	To overcome these limitations, a new set of APIs has been introducted. In this section they will be explained, underlining the main features and limitations you can get from your board.
	<br>
	<br>
	This section specifically covers: <a href="advanced_ctrl.html#pwm">PWM</a>, <a href="advanced_ctrl.html#timer">timer</a> and <a href="advanced_ctrl.html#analog">analog acquisition</a>.
	</p>
	<hr>
	<span id="pwm"></span>
	<h2>PWM generation</h2>
	<p align=justify>
	In the Arduino framework, the function assigned to PWM generation is <code>analogWrite</code>.
	<br>
	<br>
	<code>analogWrite</code> allows you to select a pin and a duty cycle your PWM pulse will have. The duty cycle is expressed as an unsigned integer between 0 and 255 for 8 bit write resolution (that is the default resolution). Resolution can also be changed by using <code>analogWriteResolution</code> function. 
	As example, we can use <code>analogWriteResolution</code> to change write resolution to 10 bit and then call <code>analogWrite</code> function to generate a pulse with 50% of duty cycle on pin 13 as shown in the following code snippet:
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="keywordflow"> analogWriteResolution</span>(10);</div><div class="line"></div><div class="line"><span class="keywordflow"> analogWrite</span>(13, 512);</div><div class="line"></div></div>
	<p align=justify>
	In SAMD21 only pins internally connected to an hardware timer can generate a PWM pulse. Timers in SAMD21 can be of two types: TC (Timer/Counter) and TCC (Timer/Counter for Control Applications). Both of them can be used as timer in an application or for PWM generation by routing their output to a specific pin they are connected to.
	<br>
	If a timer is used to generate PWM pulses, it cannot be used as control timer at the same time. Please read at <a href="advanced_ctrl.html#timer">Timer</a> section for information about resource sharing and how to manage them.
	<br>
	<br>
	In the Arduino framework, the MBC-WB allows you to generate PWM pulse on the following pins connected to SAMD21: <code>11, 12, 13, 14, 15, 18, 20, 21, 22, 23, 24 and 25</code>. To know where these pins are located, please refer to <a href="pinout.html">pinout</a> section of this documentation.
	<br>
	<br>
	<span id="pwmAssignement"></span>
	The table below summarizes the timer used by each pin when generate PWM pulses using <code>analogWrite</code> function:
	</p>
	<table class="table">
		<tr>
			<th class="th">MBC-WB pin</th>
			<th class="th">Timer</th>
		</tr>
		<tr>
			<td class="td" style="background-color:Orange;">11</td>
			<td class="td" style="background-color:Orange;">TC4 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:LightSteelBlue;">12</td>
			<td class="td" style="background-color:LightSteelBlue;">TC3 CH0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:SteelBlue;">13</td>
			<td class="td" style="background-color:SteelBlue;">TCC1 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleTurquoise;">14</td>
			<td class="td" style="background-color:PaleTurquoise;">TCC0 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleTurquoise;">15</td>
			<td class="td" style="background-color:PaleTurquoise;">TCC0 CH0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:Orange;">19</td>
			<td class="td" style="background-color:Orange;">TC4 CH0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:Orange;">20</td>
			<td class="td" style="background-color:Orange;">TC4 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:CadetBlue;">21</td>
			<td class="td" style="background-color:CadetBlue;">TC5 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:CadetBlue;">22</td>
			<td class="td" style="background-color:CadetBlue;">TC5 CH0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleVioletRed;">23</td>
			<td class="td" style="background-color:PaleVioletRed;">TCC2 CH0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleVioletRed;">24</td>
			<td class="td" style="background-color:PaleVioletRed;">TCC2 CH1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:SteelBlue;">25</td>
			<td class="td" style="background-color:SteelBlue;">TCC1 CH1</td>
		</tr>
	</table>
	<hr>
	<p align=justify>
	<b>NOTE</b>: For more information about how timers are assigned to pins, please refer to SAMD21 datasheet.
	</p>
	<hr>
	<p align=justify>
	<code>analogWrite</code> function provides a simple way to generate PWM pulses. However, it generates pulses with a fixed frequency of 732 Hz. The only parameter you can change is the duty cycle. If you have set a different frequency, you may need to act directly on SAMD's registers.
	<br>
	<br>
	To overcome this limit, a new function has been defined: <code>analogWriteFreq</code>. This function works exactly as <code>analogWrite</code> function, but beyond pin number and duty cycle, it takes a third parameter that specify the frequency the pulse should be generated at. This parameter is an unsigned interger, that let you specify frequency from 1Hz up to the maximum allowed frequency (see <a href="advanced_ctrl.html#pMarks">PWM benchmarks</a> for details). 
	<br>
	<br>
	The frequency set with this function is specific for each pin; this means that it is possible to set different frequencies for each pin that has to generate a PWM pulse. Once the frequency is specified, you can change duty cycle by calling <code>analogWrite</code> function as always, this will not overwrite the selected frequency, which can then be set just once.
	If, instead, you need to change frequency after a while, you can simply call <code>analogWriteFreq</code> again with the desired frequency.
	<br>
	<br>
	The function usage can be seen looking at the classical Arduino Fade example: to set the LED light fade rate at a frequency of 1 KHz we just call <code>analogWriteFreq</code> in the <code>setup</code> function and then use <code>analogWrite</code> as always:
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> int</span> led = 13;</div><div class="line"><span class="charliteral"> int</span> brightness = 0;</div><div class="line"><span class="charliteral"> int</span> fadeAmount = 5;</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> setup() {</div><div class="line"><span class="keywordflow">  pinMode</span>(led, <span class="charliteral">OUTPUT</span>);</div><div class="line"><span class="keywordflow">  analogWriteFreq</span>(led, brightness, 1000);  <span class="comment">// initialize PWM on pin 13, initial duty cycle 0 and frequency 1000Hz</span></div> <div class="line"> }</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> loop() {</div><div class="line"><span class="comment">  // set the brightness of pin 13:</div><div class="line"><span class="keywordflow">  analogWrite</span>(led, brightness);</div><div class="line"></div><div class="line"><span class="comment">  // change the brightness for next time through the loop:</div><div class="line">  brightness = brightness + fadeAmount;</div><div class="line"></div><div class="line"><span class="comment">  // reverse the direction of the fading at the ends of the fade:</div><div class="line">  <span class="keywordflow">if</span> (brightness &lt;= 0 || brightness &gt;= 255) {</div><div class="line">    fadeAmount = -fadeAmount;</div><div class="line">  }</div><div class="line"><span class="comment">  // wait for 30 milliseconds to see the dimming effect</div><div class="line"><span class="keywordflow">  delay</span>(30);</div><div class="line"> }</div><div class="line"></div></div><!-- fragment -->
	<hr>
	<p align=justify>
	<b>NOTE:</b> Pins sharing the same timer can have different duty cycle, but not different frequencies: changing the frequency for a pin means changing the  frequency for all the pins connected to the same timer.
	</p>
	<hr>
	<h4 id="pMarks">PWM benchmarks</h4>
	<p align=justify>
	The precision of the frequency used to generate PWM pulses changes accordingly to the type of timer used. In general, PWM generated with TCC timer are more precise than the ones generated with TC timer.
	<br>
	<br>
	<b>TCC</b> timers are able to generate PWM pulses of any frequency in the range <b>1 Hz to 16 MHz</b>.
	<br>
	<br>
	<b>TC</b> timer can generate pulses with fixed frequency steps until 183 Hz. 
	So if none of the fixed frequencies is directly chosen by the user, the timer will be set to the nearest possible fixed frequency. <br>
	Beyond 183 Hz it can generate a PWM signal with any frequency in the range between <b>183 Hz and 10 MHz</b>.
	<br>
	The currently supported TC frequencies are:
	</p>
	<ul>
	<li>2,86 Hz</li>
	<li>11,44 Hz</li>
	<li>45,7 Hz</li>
	<li>91,5 Hz</li>
	<li>any frequency between 183 Hz and 10 MHz</li>
	</ul>
	<p align=justify>
	TCC timers are also able to generate pulses under 1 Hz of frequency. You are suggested to look at SAMD21 datasheet if your application requires to reach such frequencies.
	</p>
	<h4>PWM on ESP32</h4>
	<p align=justify>
	You can also generate PWM pulses by using ESP32. On MBC-WB board, ESP32 supports PWM generation on the following pins: <code>0, 1, 2, 3, 4, 5, 6, 9, 10, 33, 34, 35, 36, 37</code>. Refer to <a href="pinout.html">pinout</a> section to know the location of these pins.
	<br>
	<br>
	ESP32 has a complete different way to generate PWM pulses. However, <code>analogWrite</code> function and <code>analogWriteFreq</code> function are available to get the same behaviour you can notice on SAMD21.
	<br>
	More specifically, <code>analogWrite</code> function will let you generate a PWM pulse with a frequency of 732 Hz, whilst <code>analogWriteFreq</code> gives you the possibility to specify the frequency the PWM pulse should be generated at. 
	The same considerations done before about <code>analogWrite</code> and <code>analogWriteFreq</code> applies also in this case.
	<br>
	<br>
	The main difference with SAMD21 is the maximum frequency the PWM can be generated at. For ESP32 the maximum allowed frequency is <b>80 MHz / 2^precision</b>, where precision can be any number in the range 1 - 15.
	<br>
	This means that with a resolution of 8 bit, the maximal allowed frequency is 312.5 kHz. You can notice that SAMD21 is able to reach higher frequencies than ESP32. This is why for high precision control application, SAMD21 is the suggested microcontroller to work with.
	</p>
	<hr>
	<span id="timer"></span>
	<h2>Timer</h2>
	<p align=justify>
	For SAMD21, Arduino APIs does not provide any function to set up timers at a specified frequency nor callback functions to call when the timeout occurs. This implies that users have to write their own driver to interact with timers or use a third-party library.
	<br>
	With an external library, the user will have zero control on which timer is used and whether it will interfere with other functions/peripheral or not during the PWM generation.
	<br>
	<br>
	In order to have a single point of access to all the timers, we defined some new APIs, directly embedded into the Arduino Core. These functions will make you simple to start a timer with a given frequency and call a callback function when a timeout occurs. The biggest advantage related to these functions relies on the automatic resource management: if a timer is used by a PWM function, it won't be used to timing your application.
	<br>
	<br>
	The new defined functions are:
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> int8_t</span> <span class="keywordflow">startTimer</span>(<span class="charliteral">uint32_t</span> n_micros, <span class="charliteral">void</span> (*callback)());</div><div class="line"></div></div>
	<p align=justify>
	This function allows you to start a timer with just two parameters: the time interval espressed in microseconds, and a function to be called everytime a timeout occurs. This callback function takes no argument and returns no value.
	<br>
	<code>startTimer</code> returns an integer that identify the timer being used for the timings function just started: the timer ID. If there is no timer available the function returns -1.
	<br>
	<br>
	The function will look for the first available timer, discarding those timers currently used with <code>analogWrite</code> function or affected by a previous call to <code>startTimer</code> function. Once a free timer is found, it is started and its ID is returned.
	<br>
	<br>
	The timer ID identifies one of the 6 timer instance of SAMD21. The following table highlights the correspondence between timer ID and SAMD21's hardware timer:
	</p>
	<table class="table">
		<tr>
			<th class="th">Timer ID</th>
			<th class="th">Timer instance</th>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleTurquoise;">0</td>
			<td class="td" style="background-color:PaleTurquoise;">TCC0</td>
		</tr>
		<tr>
			<td class="td" style="background-color:SteelBlue;">1</td>
			<td class="td" style="background-color:SteelBlue;">TCC1</td>
		</tr>
		<tr>
			<td class="td" style="background-color:PaleVioletRed;">2</td>
			<td class="td" style="background-color:PaleVioletRed;">TCC2</td>
		</tr>
		<tr>
			<td class="td" style="background-color:LightSteelBlue;">3</td>
			<td class="td" style="background-color:LightSteelBlue;">TC3</td>
		</tr>
		<tr>
			<td class="td" style="background-color:Orange;">4</td>
			<td class="td" style="background-color:Orange;">TC4</td>
		</tr>
		<tr>
			<td class="td" style="background-color:CadetBlue;">5</td>
			<td class="td" style="background-color:CadetBlue;">TC5</td>
		</tr>

	</table>
	<p align=justify>
	A timer can be stopped at any time by calling <code>stopTimer</code> function with its associated ID as argument:
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">stopTimer</span>(<span class="charliteral">uint8_t</span> timerId);</div><div class="line"></div></div>
	<p align=justify>
	Once the timer has been stopped the function will free the allocated resources.
	<br>
	<br>
	To keep track of the remaining available timers, the function to call is <code>availableTimers</code>:
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> uint8_t</span> <span class="keywordflow">availableTimers</span>();</div><div class="line"></div></div>
	<p align=justify>
	This function returns the number of free timers that can be still started for timing purpose.
	<br>
	<br>
	With the functions described above it is possible to add timing to your application without having to worry about resource sharing with PWM. 
	Despite this, it's always possible that external libraries will interact with hardware timers or someone needs to use a specific timer and don't want it to be used by these functions. 
	To this aim we defined two utility functions to better manage timers usage.
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">allocateTimer</span>(<span class="charliteral">uint8_t</span> timerId);</div><div class="line"></div></div>
	<p align=justify>
	With this function it is possible to specify that the timer associated to the ID passed as argument, should not be considered availabl and it won't be used by the functions described above. This ensures that no resource conflict will happen if some timer is used outside the standard Arduino APIs.
	</p>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> bool</span> <span class="keywordflow">isTimerUsed</span>(<span class="charliteral">uint8_t</span> timerId);</div><div class="line"></div></div>
	<p align=justify>
	This function can be used to check if the timer instance, identified by the timer ID passed as argument, is currently in use or it is available. The function returns <code>true</code> if the timer is already in use, <code>false</code> otherwise.
	<br>
	<br>
	<hr>
	<b>NOTE:</b> when using these functions to setup a timer, PWM configuration has higher priority than the configuration as a simple timer. This means that a timer already configured, up and runnig as a simple timer will see its configuration overwritten by a call to cofigure it as PWM timer. 
	<hr>
	<br>
	The result is that the timer starts acting as PWM generator and the previously defined callback won't be called anymore. 
	<br>
	On the other hand, if a timer has been configured to generate PWM pulses, in no way it can be reconfigured as a simple timer without a prior dispose of its allocated resurces.
	<br>
	You can use <code>allocateTimer</code> function if you need to start the timer before the PWM pulse, by passing the <a href="advanced_ctrl.html#pwmAssignement">timer instance your PWM will use</a>, as to ensure PWM will not interrupt your timer.
	</p>
	<h4>Timer on ESP32</h4>
	<p align=justify>
	ESP32 provides its own functions to work with timers. In addition, timers in ESP32 do not interfere with PWM generation, hence you don't need to take any special care if you need to work with both.
	<br>
	<br>
	To have an overview of timers in ESP32 you can look at the available examples in <i>File > Examples > Examples for Briki MBC-WB > ESP32 > Timer</i> or, by using Ticker library, in <i>File > Examples > Examples for Briki MBC-WB > Ticker</i>.
	<br>
	<br>
	The only thing to be noticed when working with timers in ESP32 is that it runs a FreeRTOS kernel that allows to generate concurrent threads. This implies that your code is constantly scheduled among all the different threads. Scheduling may affect execution time of your application, hence timers may lose precision in case your application needs to be scheduled with other threads.
	</p>
	<hr>
	<span id="analog"></span>
	<h2>Analog acquisition</h2>
	<p align=justify>
	The MBC-WB exposes 14 pins with analog capabilities: 10 of them (from A0 to A9) belongs to SAMD21, whilst the remaining 4 (from A10 to A13) belongs to ESP32.
	<br>
	<br>
	Arduino classical APIs only allow to call <code>analogRead</code> to start an AD conversion or select the ADC resolution by calling <code>analogReadResolution</code> function and passing to it the desired resolution (8, 10 or 12 bits). 
	<br>
	However, SAMD21 has a richer set of functionalities to perform AD conversions. The following functions expose all the SAMD21's analog features to give the user a full control over the ADC. 
	<br>
	<br>
	<hr>
	<b>NOTE:</b> these functions derive from SAMD21's hardware features, thus they are not defined for ESP32.
	<hr>
	</p>
	<h4>Analog functions</h4>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogReadGain</span>(<span class="charliteral">eAnalogGain</span> g);</div><div class="line"></div></div>
	<p align=justify>
	The SAMD21 features a flexible input selection capable of both differential and single-ended measurements plus an optional gain stage suitable to increase the dynamic range. This last stage can be controlled with <code>analogReadGain</code> function in order to set a gain ranging from 0.5x up tp 16x. The default value is 0.5x.
	<br>
	<br>
	The input parameter specifies the dynamic range. Allowed values are:
	</p>
	<ul style="list-style-type: none;">
		<li>- AG_0_5X => gain set to 0.5x</li>
		<li>- AG_1X => gain set to 1x</li>
		<li>- AG_2X => gain set to 2x</li>
		<li>- AG_4X => gain set to 4x</li>
		<li>- AG_8X => gain set to 8x</li>
		<li>- AG_16X => gain set to 16x</li>
		<li>- AG_DEFAULT =>(same as AG_0_5X)</li>
	</ul>
	<br>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogReadCorrection</span>(<span class="charliteral">int</span> offset, <span class="charliteral">uint16_t</span> gain);</div><div class="line"></div></div>
	<p align=justify>
	Inherent gain and offset errors affect the absolute accuracy of the ADC. 
	<br>
	The offset error is defined as the deviation of the actual ADC transfer function from an ideal straight line at zero input voltage. 
	<br>
	The gain error is defined as the deviation of the last output step’s midpoint from the ideal straight line, after compensating for offset error.
	<br>
	<br>
	The SAMD21 features the in-hardware offset ang gain compensation, without the need of specific code fuctions. To correct these two errors, the Digital Correction Logic must be enabled, the Offset value and Gain value must be stored respectively into the Offset Correction register and the Gain Correction register.
	<br>
	<br>
	Once all is setup properly, the ADC hardware will automatically compensate these errors giving a result based on the formula:
	<br>
	<code>Result = (Conversion value − Offset value) * Gain value</code>
	<br>
	<br>
	The correction will introduce a latency of 13 ADC clock cycles. In free running mode this latency is introduced on the first conversion only, since its duration is always less than the propagation delay. In single conversion mode this latency is introduced for each conversion.
	</p>
	<br>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogCalibrate</span>(<span class="charliteral">void</span>);</div><div class="line"></div></div>
	<p align=justify>
	<code>analogCalibrate</code> takes the BIAS and LINEARITY calibration values acquired during the production test and stored in the NVM Software Calibration Area and loads them into the ADC Calibration register to achieve specified accuracy.
	<br>
	<br>
	The accuracy of the ADC determines how close the actual digital output is to the theoretically expected digital output for a given analog input. In other words, the accuracy of the converter determines how many bits in the digital output code represent useful information about the input signal. The accuracy of the ADC is a function of its internal circuitry and noise from external sources connected to the ADC input.
	</p>
	<br>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogPrescaler</span>(<span class="charliteral">uint8_t</span> val);</div><div class="line"></div></div>
	<p align=justify>
	The ADC is clocked by GCLK_ADC. This clock can be prescaled to enable conversion at lower clock rates with <code>analogPrescaler</code> function.
	<br>
	<br>
	The input parameter represents the value the clock can be prescaled by. Allowed values are:
	</p>
	<ul style="list-style-type: none;">
		<li>- ADC_CTRLB_PRESCALER_DIV4_Val => Peripheral clock divided by 4</li>
		<li>- ADC_CTRLB_PRESCALER_DIV8_Val => Peripheral clock divided by 8</li>
		<li>- ADC_CTRLB_PRESCALER_DIV16_Val => Peripheral clock divided by 16</li>
		<li>- ADC_CTRLB_PRESCALER_DIV32_Val => Peripheral clock divided by 32</li>
		<li>- ADC_CTRLB_PRESCALER_DIV64_Val => Peripheral clock divided by 64</li>
		<li>- ADC_CTRLB_PRESCALER_DIV128_Val => Peripheral clock divided by 128</li>
		<li>- ADC_CTRLB_PRESCALER_DIV256_Val => Peripheral clock divided by 256</li>
		<li>- ADC_CTRLB_PRESCALER_DIV512_Val => Peripheral clock divided by 512</li>
	</ul>
	<br>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogHWAveraging</span>(<span class="charliteral">eAnalogAccumuDepth</span> acc, <span class="charliteral">eAnalogDivFact</span> div);</div><div class="line"></div></div>
	<p align=justify>
	<code>analogHWAveraging</code> function enables hardware signal averaging. Signal averaging is a signal processing technique applied in the time domain, intended to increase the strength of a signal relative to noise at the cost of a reduced sampling rate. By averaging a set of replicate measurements, the Signal-to-Noise Ratio (SNR) will be increased, ideally in proportion to the number of measurements; in particular the random noise components are reduced by a factor equal to the square root of the number of averaged cycles.
	<br>
	<br>
	Many and different are the sources of noise that affect the SNR and degrade the conversion quality: the source impedance, the thermal noise generated by resistive elements, the other signals present on the PCB itself (in particular the digital ones) and many more. Signal averaging typically relies heavily on the assumption that the noise component of a signal is random, having zero mean, and being unrelated to the signal. Over time, the value of Gaussian distribution noise averages to zero, so by taking an average of several signal cycles, the random noise error can be removed.
	<br>
	<br>
	Using an hardware approach to the signal averaging, instead of a software one, gives some advantages: it is faster then a dedicated code function and no code is needed to process the data acquired, it is simply required to properly setup the hardware function and get back filtered data without any intervention from the CPU, leaving more room for the execution of other function in the meanwhile.
	<br>
	<br>
	The function takes as input parameter the number of accumulation samples and the division factor.
	<br>
	The first parameter, eAnalogAccumuDepth, takes care of all the accumulation values. Allowed values for this parameter are:
	</p>
	<ul style="list-style-type: none;">
		<li>- ACCUM_1_SAMPLE => 1 sample accumulation, intermediate result precision = 12 bits, number of automatic right shift = 0</li>
		<li>- ACCUM_2_SAMPLE => 2 sample accumulation, intermediate result precision = 13 bits, number of automatic right shift = 0</li>
		<li>- ACCUM_4_SAMPLE => 4 sample accumulation, intermediate result precision = 14 bits, number of automatic right shift = 0</li>
		<li>- ACCUM_8_SAMPLE => 8 sample accumulation, intermediate result precision = 15 bits, number of automatic right shift = 0</li>
		<li>- ACCUM_16_SAMPLE => 16 sample accumulation, intermediate result precision = 16 bits, number of automatic right shift = 0</li>
		<li>- ACCUM_32_SAMPLE => 32 sample accumulation, intermediate result precision = 17 bits, number of automatic right shift = 1</li>
		<li>- ACCUM_64_SAMPLE => 64 sample accumulation, intermediate result precision = 18 bits, number of automatic right shift = 2</li>
		<li>- ACCUM_128_SAMPLE => 128 sample accumulation, intermediate result precision = 19 bits, number of automatic right shift = 3</li>
		<li>- ACCUM_256_SAMPLE => 256 sample accumulation, intermediate result precision = 20 bits, number of automatic right shift = 4</li>
		<li>- ACCUM_512_SAMPLE => 512 sample accumulation, intermediate result precision = 21 bits, number of automatic right shift = 5</li>
		<li>- ACCUM_1024_SAMPLE => 1024 sample accumulation, intermediate result precision = 22 bits, number of automatic right shift = 6</li>
	</ul>
	<p align=justify>
	The second parameter, eAnalogDivFact, takes care of all the right shift (division) factors. Allowed values for this parameter are:
	</p>
	<ul style="list-style-type: none;">
		<li>- DIV_FACT_1 => 0 right shift, equal to divide the result for 1</li>
		<li>- DIV_FACT_2 => 1 right shift, equal to divide the result for 2</li>
		<li>- DIV_FACT_4 => 2 right shift, equal to divide the result for 4</li>
		<li>- DIV_FACT_8 => 3 right shift, equal to divide the result for 8</li>
		<li>- DIV_FACT_16 => 4 right shift, equal to divide the result for 16</li>
	</ul>
	<p align=justify>
	By combining these two parameters in the funcion analogHWAveraging, different output resolutions can be achieved: for example combining ACCUM_8_SAMPLE and DIV_FACT_8 you will get an intermediate resolutione of 15 bits due to accumulation and a final output resolution of 12 bits due to a right shift of 3 positions. Using the same ACCUM_8_SAMPLE with DIV_FACT_2 this time, leads to an output resolution of 14 bits.
	</p>
	<hr>
	<b>NOTE</b>: be careful that <code>analogHWAveraging</code> automatically configure the ADC sampling rate to a preset value depending on the averaging value selected. If a different clock prescale factor has to be choose, please, call the <code>analogPrescaler</code> function right after this one.
	<hr>
	<br>
	<div class="fragment"><div class="line"></div><div class="line"><span class="charliteral"> void</span> <span class="keywordflow">analogOversamplingAndDecimate</span>(<span class="charliteral">eOversamplingVal</span> ovs);</div><div class="line"></div></div>
	<p align=justify>
	To accurately convert an analog signal into its digital representation, the ADC must have some specific characteristics:
	</p>
	<ul>
		<li>a sampling rate high enough to provide a sufficient number of samples to adequately represent the input signal. Based on the Nyquist-Shannon Sampling Theorem, the minimum sampling rate must be at least twice the frequency of the highest frequency component in the target signal (Nyquist Frequency).</li>
		<li>an adequate sampling resolution capable of faithfully recreate the amplitude variation of the input signal. As long as the signal is sampled at or above the Nyquist Frequency, post-processing techniques can be used to interpolate intermediate values and reconstruct the original input signal to within desired tolerances.</li>
	</ul>
	<p align=justify>
	Since many MCUs usually don't have ADCs with an high number of bit (typical is 10-12 bits), there are alternative methods that can enhance digital sampling results with relatively simple post-processing. The Oversampling and Decimation is one of them.
	<br>
	<br>
	This technique involves oversampling of the input signal so that a number of samples can be used to compute a virtual result with greater accuracy than a single real sample can provide.
	Oversampling simply refers to sampling the signal at a rate much higher than the Nyquist Frequency. The increased sampling rate does not directly improve ADC resolution, but by providing more	samples, the input signal can be tracked more accurately by better utilizing the existing ADC dynamic range.
	<br>It should be clear that oversampling by itself improves the digital representation of the signal only down to the physical dynamic range limit (minimum step size) of the ADC. Increasing the sampling rate further without additional post-processing simply results in multiple samples of the same value during each step in the waveform, yielding no real improvement in the basic digital conversion.
	Once the oversampling is done, we can simply sum the samples during a given sampling interval to derive a value that represents the value of the input during that sampling interval. For example, when we sum sixteen 12-bit values, the result is a 16-bit (decimated) result. In addition to yielding a more accurate approximation of the signal value during a given sampling interval, decimation also helps to improve the signal-to-noise ratio (SNR) of the input signal. By spreading the effects of random noise over multiple samples and computing a sum, decimation allows the noise to be partially cancelled from the final result.
	<br>
	<br>
	In SAMD21 the oversampling and decimate is directly done in hardware, without the need of any code function except the one needed to properly configure the ADC registers. The ADC resolution can be increased from 12 bits up to 16 bits, for the cost of reduced effective sampling rate. 
	To increase the resolution by n bits, 4^n samples must be accumulated. The result must then be right-shifted by n bits. This right-shift is a combination of the automatic right-shift done by hardware itself and the value passed as input parameter to the function.
	<br>
	The input parameter, eOversamplingVal, sets the resulting bit depth for the AD conversion (from 13 up to 16 bits). Allowed values for this parameter are:
	</p>
	<ul style="list-style-type: none;">
		<li>- OVERSAMPLED_RES_13BIT => number of samples to average = 4, number of automatic right shift = 0</li>
		<li>- OVERSAMPLED_RES_14BIT => number of samples to average = 16, number of automatic right shift = 0</li>
		<li>- OVERSAMPLED_RES_15BIT => number of samples to average = 64, number of automatic right shift = 2</li>
		<li>- OVERSAMPLED_RES_16BIT => number of samples to average = 256, number of automatic right shift = 4</li>
	</ul>
	Final conversion of ADC is now at 13, 14, 15 or 16 bits wide.
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>