<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MBC-WB Documentation: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MBC-WB Documentation
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">MBC-WB Documentation</div>  </div>
</div><!--header-->
<div class="contents">
	<h2>Introduction</h2>
	<p align=justify>
	The aim of this document is to explain the main software features of the MBC-WB in the Arduino<sup>&#174;</sup> IDE environment. To quickly set up the Arduino environment to work with MBC-WB, take a look to <a href="install_instruction.html"><b>Platform Installation</b></a> section.
	<br>
	<br>
	The Arduino IDE environment is intended to simplify the user experience. However other IDEs can be used to interact with the board, provided that supplied tools are used to upload the firmware. For instructions regarding manually uploading firmware, see <a href="otherIDEs.html"><b>Use other IDEs</b></a> section.
	<br>
	<br>
	The MBC-WB features 2 microcontrollers on board: one SAMD21 (ATSAMD21G18A) and one ESP32 (ESP32-D0WD). Both the MCUs are fully accessible in programming.
	<br>
	<br>
	The two microcontrollers are complementary: each one adds unique features to the board and enanches the weak points of the companion microcontroller.
	<br>
	The ESP32 allows WiFi and Bluetooth (BR/EDR and 4.2) communication and features a dual core 240MHz processor. SAMD21 has a 48MHz microcontroller with an high quality analog/digital section that makes it the best choice for reading sensors and controlling actuators.
	<br>
	Unlike most boards with a WiFi module you can find on the market, here it's up to you to decide who is the master microcontroller and what kind of information are excanghed between the twos. This will let the MBC fit your application, avoiding any waste of resources.
	<br>
	<br>
	To get more information about how WiFi module can be used, take a look at <a href="using_wifi.html">Using WiFi module</a> section. If you are interested in achieving better performances from the control features of SAMD microcontroller, look at <a href="advanced_ctrl.html">Advanced control features</a> section.
	<br>
	<br>
	If you need more specific information about the board and/or other development environments, please visit <a href="https://www.briki.org/faq-support/" target="_blank" rel="noopener noreferrer">support</a> section of our <a href="https://www.briki.org/" target="_blank" rel="noopener noreferrer">website</a>.
	</p>

	<h2>Firmware upload: USB</h2>
	<p align=justify>
	The SAMD21 is the chip directly connected to the USB connector. This means it will be responsible for firmware updates, on both the MCUs, throught the USB interface.
	<br>
	<br>
	The application in charge of firmware updates is the SAMD's bootloader. The SAMD's bootloader is a custom implementation of the standard SAM-BA bootloader.
	It is able to parse and execute all the SAM-BA instructions, plus some customized commands have been added to enable programming of ESP32.
	<br>
	<br>
	To actually upload some firmware in the board, the Arduino IDE foresees a very simple method.
	<br>After having selected "Briki MBC-WB" board from Tools menu, it will be enough selecting the target of the upload from <i>Tools > Processor</i> menu (the available choises are SAMD21 or ESP32).
	Now just press upload button on the Arduino IDE: the IDE will compile the current sketch and will load it into the selected target.
	</p>
	<p align=center>
	<img src="processor_selection.gif" alt="processor selection" style="width:40%; height:auto;"/>
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: Bootloader on SAMD21 is invoked by opening and closing the USB connection at a given speed.
	This means that a part of the sketch running on SAMD21 is always listening for events on USB interface for starting bootloader when requested.
	<br>If, for some reason, SAMD21 sketch stops its execution (due to a crash or something similar) the USB connection will be lost and will not be possible to start the bootloader with the method described above.
	In this case, it is possible to manually invoke bootloader, by connecting <a href="pinout.html">samd reset pin</a> to ground twice in a brief timelap (hundreds of milliseconds). In this way the bootloader will start and the USB connection will be restored, allowing to upload new firmware images.
	</p>
	<hr>
	<a id="ota"></a>
	<h2>Firmware upload: OTA</h2>
	<p align=justify>
	It is also possible to upload the firmware onboard by using the Over The Air procedure. This method relies on WiFi communication provided by ESP32 MCU. Even in this case, it is possible to program both the MCUs.
	<br>
	<br id="defaultAP">
	OTA programming is granted by a dedicated thread in the ESP core. This thread is build behind the scenes: it is hidden from the sketch, but will be compiled and loaded in all the firmwares loaded on the ESP32.
	<br>In order to allow OTA programming even if the user sketch doesn't use WiFi connection, the thread raise an AP up, so that the board will always be reachable. The AP the board will be reachable to is <i>MBC-WB-XXXXXX</i>, where <i>XXXXXX</i> represents the final part of the MAC associated to the WiFi radio.
	<br>
	<br>
	Moving OTA programming in a dedicated thread ensure that, even if the sketch application freezes, the updating will always been possible (providing that the sketch application doesn't lead to repeated board resets).
	<br>
	<br>
	To actually upload some firmware through OTA programming a dedicated tool has been provided. See <a href="install_instruction.html#tools_install"><b>tools installation instructions</b></a> for details.
	<br>To load a sketch in one of the MCUs, just select the desired MCU from <i>Tools > Processor</i> menu and compile the sketch. After compiling is done, select <i>Tools > MBC OTA Utility</i> from Tools menu. After some moment the OTA tool will show up with the just compiled sketch already selected.
	Now, just write the IP address where the board is reachable (it will be 192.168.240.1 if the default AP is used) and press <i>Start OTA</i> button to start the upload.
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: To save power it is possible to disable the default AP in the application sketch. In order to do that the function <i>WiFi.disconnect()</i> can be called anywhere in the sketch.
	<br>A usage example of this function is the following:
	<div class="fragment"><div class="line"><span class="preprocessor">#include</span> "WiFi.h"</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> setup() {</div><div class="line"><span class="keywordflow">  WiFi.disconnect</span>();</div><div class="line"> }</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> loop() {}</div></div><!-- fragment -->
	<br><b>Please note that if WiFi is disabled, OTA Update will no longer be possible</b>
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: It is also possible to modify the AP's default configuration by using <a href="classWiFi2ControlClass.html#a805d4285f5b35d6ff664ae483f1bd893">setWiFiConfig()</a> function from <a href="classWiFi2ControlClass.html">WiFi2Control</a> class
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: The fastest way to know MAC address associated to your WiFi radio is checking upload output after a sketch upload on ESP microcontroller. At each programming, uploading tool will query the device some basic information, among which the MAC address:
	</p>
	<p align=center>
	<img src="mac_address.png" alt="drivers properties" align="middle" height="300" width="700">
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: When updating SAMD21 via OTA remember to close and reopen the serial monitor in order to see serial output.
	</p>
	<hr>

	<h2> <a id="gpio_control"></a>GPIO Control</h2>
	<p align=justify>
	MBC-WB has 37 pins that can be used as GPIO. Some of them are connected to SAMD21, while others to ESP32.
	<br>
	<br>In order to simplify user experience, by using the platform provided for the Arduino IDE, there's no difference when driving pins from one or another MCU. A GPIO virtualization system has been designed, so that moving pin 1 on the mbc will always have the same effect either the command is sent from SAMD or ESP MCU.
	<br>Hence, to use this GPIO virtualization system, you can call the common Arduino APIs as always (e.g. <code>digitalWrite, analogWrite</code>) and the two micro will be able to act on the right GPIO, either the command is given from SAMD21 or ESP32.
	<br>
	<br>If you're still interested in understanding how GPIOs are assigned to the two MCUs, you can refer to <a href="pinout.html">pinout reference</a>.
	<br>
	<br>The two microcontrollers use an internal <a href="comm_index.html">communication system</a> based on SPI to forward the command to the micro who actually drive the pin. In such a way, GPIOs managment is user transparent.
	</p>
	
	<h2>Communication between the 2 MCUs</h2>
	<p align=justify>
	The two MCUs can communicate using both an SPI interface and a Serial interface.
	<br>It is possible to exchange commands and raw data between the 2 MCUs with the SPI interface by using functions described in <a href="comm_index.html">MCUs Communication</a> section.
	<br>
	<br>
	The USB connector is directly connected to SAMD. Data print with Serial class in ESP micro will not be visible from USB. Since SAMD and ESP share a Serial interface, it is possible to use SAMD as "bridge" to print the data coming from ESP.
	This can be useful expecially in debug phase.
	<br>From SAMD, to access the serial connected to ESP, the SerialEsp object has been defined. The ESP will write in the serial connected to SAMD by using Serial object directly.
	<br>
	<br>
	The UartBridge example located at <i>File > Examples > Examples for Briki MBC-WB > Communication > UartBridge</i> shows how to use the serial connection on SAMD21 to print incoming data from ESP32 on USB.
	<br>
	<br>
	To ensure the maximum flexibility, there's also the possibility to power down one of the two MCUs. Indeed, both the MCUs have control on the reset pin of the other one. In this way it is possible to get better power performances if one of the two chip is not needed.
	<br>
	<br>
	The SAMD21 can power down ESP32 by using ESP_RST pin. Please note that if ESP32 is powered down, OTA updates will no longer be possible.
	<br>An example sketch that power down the ESP32 is the following:
	<br>
	<div class="fragment"><div class="line"><span class="keywordtype"> void</span> setup() {</div><div class="line"><span class="keywordflow">  pinMode</span>(<span class="charliteral">ESP_RST</span>, <span class="charliteral">OUTPUT</span>);</div><div class="line"><span class="keywordflow">  digitalWrite</span>(<span class="charliteral">ESP_RST</span>, <span class="charliteral">LOW</span>);</div> <div class="line"> }</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> loop() {}</div></div><!-- fragment --> 
	<br>
	<br>
	The ESP32 can power down SAMD21 by using COMPANION_RESET pin. Please note that if SAMD21 is powered down, USB connection will be lost and serial update will no longer be possible.
	<br>An example sketch that power down the SAMD21 is the following:
	<br>
	</p>
	<div class="fragment"><div class="line"><span class="keywordtype"> void</span> setup() {</div><div class="line"><span class="keywordflow">  pinMode</span>(<span class="charliteral">COMPANION_RESET</span>, <span class="charliteral">OUTPUT</span>);</div><div class="line"><span class="keywordflow">  digitalWrite</span>(<span class="charliteral">COMPANION_RESET</span>, <span class="charliteral">LOW</span>);</div> <div class="line"> }</div><div class="line"></div><div class="line"><span class="keywordtype"> void</span> loop() {}</div></div><!-- fragment --> 
	
	<a id="storage"></a>
	<h2>Storage</h2>
	<p align=justify>
	ESP32 flash is partitioned in different memory areas. The firmware loaded onboard is stored in a dedicated partition of the Flash memory. By default, the ESP32 Flash hosts a partition area used to store user data. This partition can be formatted to host a FAT file system or a SPIFFS file sytem.
	<br>
	<br>
	SPI Flash File System (SPIFFS) is a file system intended for flash devices on emedded targets. It can work with files using C standard library and POSIX APIs. However, it does not support directories.
	It is possible to work with SPIFFS file system in Arduino environment by using the SPIFFS library provided by Espressif<sup>&#174;</sup> (some examples are already available in the platform under <code>File > Examples > Examples for Briki MBC-WB > SPIFFS</code>).
	<br>To load some content inside the SPIFFS file system an external tool has been created to enable loading huge amount of data directly from the USB connection.
	This tool is the <i>MBC ESP32 Spiffs</i> (installation instructions available <a href="install_instruction.html#tools_install">here</a>).
	<br>
	The tool is derived from <i>ESP32FS</i> from Espressif. It basically looks for <i>"data"</i> sub folder inside the sketch folder and generates a .bin file with the content of the <i>"data"</i> directory. If no data directory is found, the tool asks if the default SPIFFS content can be loaded or an empty SPIFFS file needs to be created.
	After binary file creation, it is possible to choose whether the file have to be loaded through USB, OTA or not loaded at all (only created) and proceed with the selected operation. If uploading through USB is chosen, it is needed to close any opened serial monitor or uploading may fail.
	<br>
	<br>
	FAT is one of the most known file system. It can work with files, it supports directories and, differently from SPIFFS, it can work with encrypted data. 
	In the Arduino environment it is possible using FFat library to access this kind of filesystem (examples available under <code>File > Examples > Examples for Briki MBC-WB > FFat</code>).
	<br>Even for FAT, an external tool has been created, in order to load files and directories directly from USB. This tool is <i>MBC ESP32 Fatfs</i> and can be installed as any other tool by following related <a href="install_instruction.html#tools_install">instructions</a>.
	<br>
	The behaviour of the FAT tool is the same as the SPIFFS one. It looks for a <i>"data"</i> folder inside the sketch folder and generates a binary ready to be loaded in the partition. If no data directory is found, the tool asks if you want to load the default content or an empty FAT file system. Then you will be asked the way you want to upload the file system: if using USB connection, OTA update or if you just want to create the file system without uploading it.
	<br>
	<br>
	To summarize, if you want to customize storage partition content, you can do it with few basic steps: identify your sketch folder (you can easily do it by selecting <i>Sketch > Open sketch folder</i> menu or by clicking <code>Ctrl + K</code> from the Arudino IDE), create a <i>data</i> folder in this location, put your files inside it and launch MBC ESP32 Spiffs or Fatfs tool.
	<br>
	<br>
	To choose wether using SPIFFS or FAT filesystem you can select the desired file system in <code>Tools</code> menu of the Arduino IDE. When Briki MBC-WB is selected as board, in <code>Tools</code> menu the entry <i>ESP Flash Partition</i> will let you choose between SPIFFS or FFAT storage. This will change partition table accordingly to the choice made.
	<p align=center>
	<img src="partition_table.gif" alt="storage selection" style="width:45%; height:auto;"/>
	</p>
	<p align=justify>
	Please note that storage tool should be used accordingly to the flash partition chosen. If using FFAT storage then MBC ESP32 Fatfs tool should be used. At the same way MBC ESP32 Spiffs should be used when SPIFFS storage is selected in <code>Tools</code> menu.
	<br>Also, be aware of the fact that chosing a kind of partition from <code>Tools</code> menu won't change the partition table inside the board. If you want to load a partition table you will need to load a sketch in the board with ESP32 processor selected. Only after the code is loaded the partition will be marked with the selected storage type and you can start using the related storage tool.
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: The default storage content is the one needed to work with <a href="classWebPanelClass.html">web panel</a> from <a href="classWiFi2ControlClass.html">WiFi2Control</a> library.
	</p>
	<hr>
	<p align=justify>
	<i>Note</i>: When using storage tool (SPIFFS / FFAT) updating with USB, serial monitor must be closed or upload will fail.
	</p>
	<hr>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
